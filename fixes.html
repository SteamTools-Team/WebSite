<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Fixes ‚Äì Cache + SteamDB</title>
<link rel="stylesheet" href="assets/style.css">
<style>
/* Ajustements sp√©cifiques √† la grille des fixes, en r√©utilisant les variables globales */
.container{max-width:1100px;}
#controls{display:flex;gap:10px;justify-content:center;margin:20px 0;}
#search{flex:1;max-width:420px;padding:10px 14px;border-radius:10px;border:1px solid var(--border-color);background:var(--accent-bg);color:var(--text-primary);}
#reload{padding:10px 18px;border-radius:10px;border:none;background:linear-gradient(135deg,var(--violet-primary),var(--violet-hover));color:white;font-weight:600;cursor:pointer;}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:16px;margin-top:20px;}
.card{background:var(--accent-bg);border:1px solid var(--border-color);border-radius:14px;overflow:hidden;text-decoration:none;color:inherit;transition:.3s;}
.card:hover{transform:translateY(-3px);box-shadow:0 8px 25px rgba(140,122,230,.3);}
.card img{width:100%;height:140px;object-fit:cover;filter:brightness(0.88);background:#151525;}
.card .info{padding:12px;}
.filename{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.size{font-size:.85rem;color:var(--text-secondary);margin-top:4px;}
.empty{text-align:center;color:var(--text-secondary);margin-top:40px;}
</style>
</head>
<body>
<div class="container">
  <h1>üéÆ Liste des Fixes</h1>
  <div id="controls">
    <input id="search" type="search" placeholder="Rechercher un jeu...">
    <button id="reload">Recharger</button>
  </div>
  <div id="content"></div>
</div>

<script>
const SOURCE_URL = "https://generator.ryuu.lol/fixes";
const CACHE_KEY = "fixes-cache";
const CACHE_TTL = 3600 * 1000; // 1 heure

let allFixes = [];

const PROXIES = [
  url => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
  url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
  url => `https://thingproxy.freeboard.io/fetch/${url}`,
];

async function fetchViaProxies(url){
  for(const make of PROXIES){
    try{
      const r = await fetch(make(url));
      if(!r.ok) continue;
      const type = r.headers.get("content-type")||"";
      if(type.includes("json")){
        const j = await r.json();
        return j.contents || j; // allorigins renvoie { contents }
      } else {
        return await r.text();
      }
    }catch(_){/* essaie le proxy suivant */}
  }
  throw new Error("Impossible de r√©cup√©rer la page source");
}

async function fetchJsonViaProxies(url){
  for(const make of PROXIES){
    try{
      const r = await fetch(make(url));
      if(!r.ok) continue;
      const type = r.headers.get('content-type')||'';
      if(type.includes('json')){
        const j = await r.json();
        const contents = j && typeof j==='object' && 'contents' in j ? j.contents : j;
        if(typeof contents === 'string'){
          try{ return JSON.parse(contents); }catch{ continue; }
        }
        return contents;
      } else {
        const t = await r.text();
        try{ return JSON.parse(t); }catch{ continue; }
      }
    }catch(_){/* essaie proxy suivant */}
  }
  throw new Error('Impossible de r√©cup√©rer le JSON via proxies');
}

function parseFixes(html){
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const anchors = [...doc.querySelectorAll("a.file-item, a[href$='.zip']")];
  return anchors.map(a=>{
    const name = (a.querySelector('.file-name')?.textContent || a.textContent || '').trim();
    const href = a.getAttribute('href') || '';
    let absoluteUrl = href;
    try { absoluteUrl = new URL(href, SOURCE_URL).toString(); } catch {}
    const size = (a.querySelector('.file-size')?.textContent || '').trim();
    return { name, url: absoluteUrl, size };
  }).filter(f=> (f.name||'').toLowerCase().includes('.zip'));
}

async function getSteamImage(gameName){
  try{
    const name = (gameName||'').replace(/\.zip$/i,'').trim();
    if(!name) return null;
    if(!window.__imgCache) window.__imgCache = new Map();
    if(window.__imgCache.has(name)) return window.__imgCache.get(name);
    
    // Essayer d'abord avec SteamGridDB (API plus ouverte)
    try{
      const clean = encodeURIComponent(name);
      const sgdbUrl = `https://www.steamgriddb.com/api/v2/search/autocomplete/${clean}`;
      const sgdbRes = await fetch(sgdbUrl);
      if(sgdbRes.ok){
        const sgdbData = await sgdbRes.json();
        if(sgdbData.success && sgdbData.data && sgdbData.data.length > 0){
          const firstGame = sgdbData.data[0];
          if(firstGame.appid){
            const header = `https://cdn.cloudflare.steamstatic.com/steam/apps/${firstGame.appid}/header.jpg`;
            window.__imgCache.set(name, header);
            console.log(`‚úì Image trouv√©e pour "${name}": ${header}`);
            return header;
          }
        }
      }
    }catch(e){ console.log(`SteamGridDB √©chou√© pour "${name}"`, e); }
    
    // Fallback: SteamDB via proxy
    try{
      const clean = encodeURIComponent(name);
      const json = await fetchJsonViaProxies(`https://steamdb.info/api/GetSearchSuggestions/?query=${clean}`);
      const first = json?.results?.[0];
      if(first && first.appid){
        const header = `https://cdn.cloudflare.steamstatic.com/steam/apps/${first.appid}/header.jpg`;
        window.__imgCache.set(name, header);
        console.log(`‚úì Image trouv√©e (SteamDB) pour "${name}": ${header}`);
        return header;
      }
    }catch(e){ console.log(`SteamDB √©chou√© pour "${name}"`, e); }
    
    console.log(`‚úó Aucune image trouv√©e pour "${name}"`);
    return null;
  }catch(e){ 
    console.error(`Erreur getSteamImage pour "${gameName}":`, e);
    return null; 
  }
}

function escapeHtml(s){return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]))}

function render(list){
  const q=document.getElementById("search").value.toLowerCase();
  const safeList=Array.isArray(list)?list:[];
  const items=safeList.filter(i=>!q||i.name.toLowerCase().includes(q));
  if(!items.length)return document.getElementById("content").innerHTML=`<div class="empty">Aucun fichier trouv√©.</div>`;
  document.getElementById("content").innerHTML=`<div class="grid">`+items.map(it=>`
    <a href="${it.url}" target="_blank" class="card">
      <img src="${it.image||'/assets/fav.ico'}" alt="" referrerpolicy="no-referrer" onerror="this.onerror=null;this.src='/assets/fav.ico';this.style.objectFit='contain';this.style.padding='12px';this.style.height='140px';">
      <div class="info">
        <div class="filename">${escapeHtml(it.name)}</div>
        <div class="size">${escapeHtml(it.size||"")}</div>
      </div>
    </a>`).join("")+`</div>`;
}

async function fetchFixes(force=false){
  const cache=localStorage.getItem(CACHE_KEY);
  if(cache&&!force){
    const data=JSON.parse(cache);
    if(Date.now()-data.timestamp<CACHE_TTL){
      allFixes=Array.isArray(data.fixes)?data.fixes:[];
      // Mettre √† jour les images m√™me depuis le cache si elles manquent
      const needsImages = allFixes.filter(f => !f.image || f.image === '/assets/fav.ico');
      if(needsImages.length > 0){
        console.log(`üîÑ Mise √† jour des images pour ${needsImages.length} jeux...`);
        const maxConcurrent = 5;
        let index = 0;
        async function worker(){
          while(index < needsImages.length){
            const i = index++;
            const f = needsImages[i];
            const img = await getSteamImage(f.name);
            if(img) f.image = img;
          }
        }
        await Promise.all(Array.from({length: Math.min(maxConcurrent, needsImages.length)}, worker));
        localStorage.setItem(CACHE_KEY,JSON.stringify({timestamp:Date.now(),fixes:allFixes}));
      }
      render(allFixes);
      console.log("üíæ Cache charg√©");
      return;
    }
  }
  document.getElementById("content").innerHTML=`<div class="empty">Chargement...</div>`;
  try{
    const html = await fetchViaProxies(SOURCE_URL);
    let fixes = parseFixes(typeof html === 'string' ? html : String(html||''));
    console.log(`üì¶ ${fixes.length} fixes trouv√©s`);
    const limited = fixes.slice(0,50);
    console.log(`üñºÔ∏è R√©cup√©ration des images pour ${limited.length} jeux...`);
    // Limiter de concurrence pour √©viter les blocages r√©seau
    const maxConcurrent = 5;
    let index = 0;
    async function worker(){
      while(index < limited.length){
        const i = index++;
        const f = limited[i];
        const img = await getSteamImage(f.name);
        if(img) f.image = img;
      }
    }
    await Promise.all(Array.from({length: Math.min(maxConcurrent, limited.length)}, worker));
    allFixes = fixes;
    localStorage.setItem(CACHE_KEY,JSON.stringify({timestamp:Date.now(),fixes:allFixes}));
    render(allFixes);
    console.log("‚ö° Cache mis √† jour");
  }catch(e){
    console.error(e);
    let msg = e;
    if(e&&typeof e==='object') msg = e.message||e.error||e.toString();
    if(typeof msg!=='string') { try{ msg = JSON.stringify(msg); }catch{ msg = 'Erreur inconnue'; } }
    document.getElementById("content").innerHTML=`<div class="empty">Erreur lors du chargement des fixes : ${escapeHtml(String(msg))}</div>`;
  }
}

document.getElementById("search").oninput=()=>render(allFixes);
document.getElementById("reload").onclick=()=>fetchFixes(true);

fetchFixes();
</script>
</body>
</html>
